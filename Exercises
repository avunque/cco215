CCO215 / Ejercicios


1. Consider the following function scramble(): 

void scramble(int i, int &j, int &k) { 
i = 10;
j = 20;
k = 30;
return; 

a) What is the output of the following program fragment? 
#include <iostream> 
#include <string> 
using namespace std; 
int main() { 
	int i = 1; 
	int j = 2; 
	int k = 3; 
	scramble(k, j, i); 
	cout "i = " « i «" « "k = " « k « endl; 
	return 0; 
} 

b) What is the output of the following program fragment? 

#include <iostream> 
#include <string> 
using namespace std; 
int main() {
	int i = 1; 
	int j = 2; 
	int k = 3; 
	scramble(j, j, j); 
	cout « "I = " « i « " j = " « « "k = " « k « endl 
	return 0; 
}



2. What is the output of the following code segment? 

int counter1 = 0;
int counter2 = 0;
int counter3 = 0;
int counter4 = 0;
int counter5 = 0;
for (int i = 0; i < 10; ++i) {
	++counter1; 
	for (int j = 0; j < 10; ++j) {
		+counter2; 
		if (i == j) {
			++counter3; 
		} 
		else {
			++counter4;
		} 
	}
	++counter5; 
}
cout « counter1 « " " « counter2 « counter3 « " " « counter4 « " " « counter5; 


3. Design and implement a program that prompts its user for a nonnegative value n. The program then displays as its output: 
1 2 3 ... n-1 n 
1 2 3 ... n-1
…
1 2 3
1 2 
1
 
(Note the ...s are to be filled in with the appropriate numbers.) 

4. Write a recursive function to compute the greatest common divisor (gcd) of two integers. The gcd of two integers is the largest integer that divides them both. A working definition of gcd is:

gcd(m, n) =  n  									//if n divides m
gcd(m, n) = gcd(n, remainder of m divided by n)     // otherwise



5. Let n be a given posititive integer. For i = 0, 1, 2, . . . define 
n[i+1]  = n[i] / 2		if n[i] is even
		= 3 n[i] + 1	if n[i] is odd 

The sequence stops whenever n[i] has the value 1.
Numbers that are generated this way are called "hailstones." Write a program that generates some hailstones. The function 

void hailstones(n) int n; 
{
	......

should be used to compute and print the sequence generated by n. Here is an example of how the output of your program might look: 

Hailstones generated by 77: 
77 232 116 58 29 88 
44  22  11 34 17 52
26  13  40 20 10  5 
16   8   4  2  1

Number of hailstones generated: 23 

You will find that all the sequences you generate are finite. Whether this is true in general is still an open question. Hint: Use variables of type long where appropriate. 

